## 第一次实验

#### 实验目标

`b0`：实现驱动的枚举

`b1`：不借助C代码实现`b0`

#### 实验内容

###### 1. 实现`b0`

实际上，我们注意到`linker_riscv64.lds`中定义了`init_calls_start`与`init_calls_end`。

我们在`initcalls.c`中可以`extern`两个变量分别与它们同名（利用`gcc`扩展可以声明为`void`类型），那么这两个变量的地址就对应着我们要获取的`range_start`和`range_end`。将地址`cast`成`uint64_t`并返回。

在`rust`侧，`extern "C"`得到`initcalls.c`中声明的两个函数，调用就可以得到`init_calls`段的区间。随后，我们可以用`slice::from_raw_parts` 将它当作`CallEntry` 数组的引用来进行处理。

如果是在`nightly`模式下，我们也可以用`slice::from_ptr_range`更方便地从首尾指针获得`slice`。



###### 2. 不借助C代码实现`b0`

在上面的过程中，我们从`C`代码侧`extern`了链接器脚本定义的变量，又从`rust`代码一侧`extern`了`C`代码定义的函数。

实际上，我们没有必要绕这么一个圈子，而是可以直接在`rust`里`extern`链接器脚本定义的变量。

和之前类似地，我们在`extern "C"`包裹的定义内放两个名为`init_calls_start`和`init_calls_end`的变量。用`u8`作类型当然可行，不过为了语义上更明确这两个变量“只有所在的地址”，我们用`core::ffi::c_void`作为变量类型。

之后就与`b0`中的`C`代码类似地，我们获取这两个变量的地址即可。



#### 关于`unsafe`的一些想法

`rust`提供的安全性要求数组长度之类的东西在“编译期”已知，而我们的这种编译结构只能做到在“链接期”知道驱动数量。

因此我们要从链接脚本中返回一些东西，这就导致了我们不得不借助一些裸指针的操作来在“运行期”获取这些信息，从而引发了一些确实存在的安全性问题。

如果一定要回避这种问题，或许需要涉及到对编译过程的大改动，比如进行多个`pass`的编译之类，或者利用`ctor`之类的方法让驱动在程序开始前主动进行注册（但是这样就需要驱动页在编译期确定下来）。
